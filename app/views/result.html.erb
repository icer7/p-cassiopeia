<p id="notice"><%= notice %></p>

<h1>計測画面</h1>

<table>

  <thead>
    <tr>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <canvas style="background-color: yellow;" id="axisCanvas"></canvas>
    <div>計測結果</div>
      <a id="test-table"></a>
  </tbody>

</table>

<br>

<script>
  var canvas, ctx;
  var canvasW = 400;
  var canvasH = 400;
  var mouseX1, mouseY1, mouseX2, mouseY2;
  var count = 0;

  window.onload = function() {
    canvas = document.getElementById('axisCanvas');
    canvas.width = canvasW;
    canvas.height = canvasH;
    ctx = canvas.getContext('2d');

    var objX1, objX2, objY;
    var objWidth, objHeight;

    objWidth = 5;
    objHeight = 200;

    // オブジェクトの座標を定義(キャンバスの中央に表示)
    objX1 = canvas.width / 2 - objWidth / 2;
    objY = canvas.height / 2 - objHeight / 2;
    objX2 = objX1 - 50;

    // オブジェクトを描画
    drawRect(objX1);
    drawRect(objX2);

    function drawRect(objX1) {
      ctx.fillRect(objX1, objY, objWidth, objHeight);
    }
    function drawRect(objX2) {
      ctx.fillRect(objX2, objY, objWidth, objHeight);
    }

    var x, y, relX1, relX2, relY;
    var dragging = false;

    function onDown(e) {
      // キャンバスの左上端の座標を取得
      var offsetX = canvas.getBoundingClientRect().left;
      var offsetY = canvas.getBoundingClientRect().top;

      // マウスが押された座標を取得
      x = e.clientX - offsetX;
      y = e.clientY - offsetY;

      // オブジェクト上の座標かどうかを判定
      if (objX1 < x && (objX1 + objWidth) > x && objY < y && (objY + objHeight) > y) {
        dragging = true; // ドラッグ開始
        relX1 = objX1 - x;
        relY = objY - y;
      }
      if (objX2 < x && (objX2 + objWidth) > x && objY < y && (objY + objHeight) > y) {
        dragging = true; // ドラッグ開始
        relX2 = objX2 - x;
        relY = objY - y;
      }
    }

    canvas.addEventListener('mousedown', onDown, false);

    function onMove(e) {
      // キャンバスの左上端の座標を取得
      var offsetX = canvas.getBoundingClientRect().left;
      var offsetY = canvas.getBoundingClientRect().top;

      // マウスが移動した先の座標を取得
      x = e.clientX - offsetX;
      y = e.clientY - offsetY;

      // ドラッグが開始されていればオブジェクトの座標を更新して再描画
      if (dragging) {
        objX1 = x + relX1;
        objY = y + relY;
        objX2 = x + relX2;
        drawRect();
      }
    }

    function onUp(e) {
      dragging = false; // ドラッグ終了
    }

    function drawRect(objX1) {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // キャンバスをクリア
      ctx.fillRect(objX1, objY, objWidth, objHeight);
      ctx.fillRect(objX2, objY, objWidth, objHeight);
    }
    function drawRect(objX2) {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // キャンバスをクリア
      ctx.fillRect(objX1, objY, objWidth, objHeight);
      ctx.fillRect(objX2, objY, objWidth, objHeight);
    }

    canvas.addEventListener('mousemove', onMove, false);
    canvas.addEventListener('mouseup', onUp, false);

    canvas.onclick = function(e) {
      if (count >= 2) {
        count = 1;
        ctx.clearRect(0, 0, canvasW, canvasH);

        var rect = e.target.getBoundingClientRect();
        mouseX1 = e.clientX - Math.floor(rect.left) - 2;
        mouseY1 = e.clientY - Math.floor(rect.top) - 2;

        ctx.beginPath();
        ctx.moveTo(mouseX1, 100, 5, 0, Math.PI * 2, false);
        ctx.lineTo(mouseX1, 300, 5, 0, Math.PI * 2, false);
        ctx.stroke();

        var test_table = ""
        var element = document.getElementById('test-table');
        element.innerHTML = test_table;
      }
      else if (count == 1) {
        count += 1;
        var rect = e.target.getBoundingClientRect();
        mouseX2 = e.clientX - Math.floor(rect.left) - 2;
        mouseY2 = e.clientY - Math.floor(rect.top) - 2;

        ctx.beginPath();
        ctx.moveTo(mouseX2, 100, 5, 0, Math.PI * 2, false);
        ctx.lineTo(mouseX2, 300, 5, 0, Math.PI * 2, false);
        ctx.stroke();

        var test_table = Math.abs(mouseX1 - mouseX2)
        var element = document.getElementById('test-table');
        element.innerHTML = test_table;
      }
      else {
        count += 1;
        var rect = e.target.getBoundingClientRect();
        mouseX1 = e.clientX - Math.floor(rect.left) - 2;
        mouseY1 = e.clientY - Math.floor(rect.top) - 2;

        ctx.beginPath();
        ctx.moveTo(mouseX1, 100, 5, 0, Math.PI * 2, false);
        ctx.lineTo(mouseX1, 300, 5, 0, Math.PI * 2, false);
        ctx.stroke();
      }
    }
  };
</script>
